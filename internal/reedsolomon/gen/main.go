package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
)

// polynomial: x^8 = x^4 + x^3 + x^2 + 1
const g = 1<<8 + 1<<4 + 1<<3 + 1<<2 + 1

var expTable [256]element
var logTable [256]int

// element is GF(2^8) performed modulo x^8 + x^4 + x^3 + x^2 + 1.
type element uint8

const zero = element(0)
const one = element(1)

// add returns x + y.
func add(x, y element) element {
	return x ^ y
}

// mul returns x * y.
func mul(x, y element) element {
	if x == zero || y == zero {
		return zero
	}
	xx := logTable[x]
	yy := logTable[y]
	zz := (xx + yy) % 255
	return expTable[zz]
}

// AddMul sets v = x + y * a^z
func (v *element) AddMulExp(x, y element, z int) {
	if y == zero {
		*v = x
		return
	}
	yz := (logTable[y] + z) % 255
	*v = add(x, expTable[yz])
}

func main() {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by gen/main.go; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package reedsolomon")

	precomputeTable(&buf)
	precomputeCoefficients(&buf)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("generated.go", out, 0o644); err != nil {
		log.Fatal(err)
	}
}

func precomputeTable(buf *bytes.Buffer) {
	fmt.Fprintln(buf, "// expTable is pre-computed value of expTable[n] = a^n performed modulo x^8 + x^4 + x^3 + x^2 + 1.")
	fmt.Fprintln(buf, "var expTable = [256]element{")
	var v uint = 1
	for i := 0; i < 16; i++ {
		for j := 0; j < 16; j++ {
			fmt.Fprintf(buf, "0x%02x,", v)
			if i*16+j < 255 {
				logTable[v] = i*16 + j
				expTable[i*16+j] = element(v)
			}
			v <<= 1
			v ^= (v >> 8) * g
		}
		fmt.Fprintln(buf)
	}
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "// expTable is pre-computed value of a^logTable[n] = n performed modulo x^8 + x^4 + x^3 + x^2 + 1.")
	fmt.Fprintln(buf, "var logTable = [256]int{ // uint8 is enough, however it is int because avoid to overflow during calculation")
	for i := 0; i < 16; i++ {
		for j := 0; j < 16; j++ {
			fmt.Fprintf(buf, "0x%02x,", logTable[i*16+j])
		}
		fmt.Fprintln(buf)
	}
	fmt.Fprintln(buf, "}")
}

func precomputeCoefficients(buf *bytes.Buffer) {
	for i := 2; i <= 68; i++ {
		coef := make([]element, i+1)
		coef[0] = one
		for j := 0; j < i; j++ {
			for k := i; k >= 1; k-- {
				coef[k].AddMulExp(coef[k], coef[k-1], j)
			}
		}

		fmt.Fprintf(buf, "type coder%d [%d]element\n", i, i)
		fmt.Fprintf(buf, "func (c *coder%d) Write(p []byte) (int, error) {\n", i)
		fmt.Fprintf(buf, "for _, b := range p {\n")
		fmt.Fprintf(buf, "x := c[0]\n")
		for j, a := range coef[1:i] {
			fmt.Fprintf(buf, "c[%d].AddMulExp(c[%d], x, %d)\n", j, j+1, logTable[a])
		}
		fmt.Fprintf(buf, "c[%d].AddMulExp(element(b), x, %d)\n", i-1, logTable[coef[i]])
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return len(p), nil\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "func (c coder%d) Code() []byte {\n", i)
		fmt.Fprintf(buf, "var buf [%d]byte\n", i)
		fmt.Fprintf(buf, "c.Write(buf[:])\n")
		fmt.Fprintf(buf, "for i := range buf {\n")
		fmt.Fprintf(buf, "buf[i] = byte(c[i])\n")
		fmt.Fprintf(buf, "}\n")
		fmt.Fprintf(buf, "return buf[:]\n")
		fmt.Fprintf(buf, "}\n")
	}
}
