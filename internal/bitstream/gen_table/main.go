package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
)

func main() {
	decodeJIS0208, err := loadJIS0208()
	if err != nil {
		log.Fatal(err)
	}
	encodeJIS0208 := reverse(decodeJIS0208)
	encodeQR := createEncodeTable(encodeJIS0208)
	encodeTables := optimizeEncodeTable(encodeQR)

	var buf bytes.Buffer
	w := &buf
	fmt.Fprintln(w, "// Code generated by gen_table/main.go; DO NOT EDIT.")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "package bitstream")

	for i, t := range encodeTables {
		fmt.Fprintf(w, "const encode%dLow, encode%dHigh = %d, %d\n", i, i, t.min, t.max)
		fmt.Fprintf(w, "var encode%d = [...]int16{", i)
		for i, code := range t.table {
			if i%16 == 0 {
				fmt.Fprintln(w)
			}
			if code >= 0 {
				fmt.Fprintf(w, "0x%04x,", code)
			} else {
				fmt.Fprint(w, "-1,")
			}
		}
		fmt.Fprintf(w, "\n}\n\n")
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("table_gen.go", out, 0o644); err != nil {
		log.Fatal(err)
	}
}

func loadJIS0208() (map[int]rune, error) {
	f, err := os.Open(filepath.Join("gen_table", "index-jis0208.txt"))
	if err != nil {
		return nil, err
	}
	defer f.Close()

	jis0208 := make(map[int]rune)
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		row := scanner.Bytes()
		row = bytes.TrimSpace(row)
		if len(row) == 0 || row[0] == '#' {
			continue
		}
		code, rest, ok := bytes.Cut(row, []byte("\t"))
		if !ok {
			return nil, errors.New("invalid row")
		}
		unicode, _, ok := bytes.Cut(rest, []byte("\t"))
		if !ok {
			return nil, errors.New("invalid row")
		}

		c, err := strconv.ParseInt(string(code), 10, 0)
		if err != nil {
			return nil, err
		}
		u, err := strconv.ParseUint(string(unicode), 0, 16)
		if err != nil {
			return nil, err
		}
		jis0208[int(c)] = rune(u)
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return jis0208, nil
}

func reverse(decode map[int]rune) map[rune]int {
	encode := make(map[rune]int, len(decode))
	for code, r := range decode {
		if encode[r] == 0 || code < encode[r] {
			encode[r] = code
		}
	}
	return encode
}

func encodeShiftJIS(code int) (s1, s2 byte, ok bool) {
	t := code%94 + 1
	k := code/94%94 + 1
	m := code/(94*94) + 1

	if m != 1 {
		return 0, 0, false
	}

	if k < 63 {
		s1 = byte((k + 257) / 2)
	} else {
		s1 = byte((k + 385) / 2)
	}
	if k%2 != 0 {
		if t < 64 {
			s2 = byte(t + 63)
		} else {
			s2 = byte(t + 64)
		}
	} else {
		s2 = byte(t + 158)
	}
	ok = true
	return
}

func encodeQR(code int) (uint16, bool) {
	s1, s2, ok := encodeShiftJIS(code)
	if !ok {
		return 0, false
	}

	s := (uint16(s1) << 8) + uint16(s2)
	if s >= 0x8140 && s <= 0x9FFC {
		s -= 0x8140
	} else if s >= 0xE040 && s <= 0xEBBF {
		s -= 0xC140
	} else {
		return 0, false
	}
	return (s>>8)*0xC0 + (s % 0x100), true
}

func createEncodeTable(encode map[rune]int) map[rune]uint16 {
	ret := make(map[rune]uint16)
	for ch, code := range encode {
		qr, ok := encodeQR(code)
		if !ok {
			continue
		}
		ret[ch] = qr
	}
	return ret
}

type encodeTable struct {
	min, max rune
	table    []int16
}

func optimizeEncodeTable(encode map[rune]uint16) []encodeTable {
	keys := make([]rune, 0, len(encode))
	for key := range encode {
		keys = append(keys, key)
	}
	sort.Slice(keys, func(i, j int) bool {
		return keys[i] < keys[j]
	})

	tables := []encodeTable{
		{
			min:   keys[0],
			max:   keys[0],
			table: []int16{int16(encode[keys[0]])},
		},
	}
	last := keys[0]
	for _, key := range keys[1:] {
		if key-last > 1000 {
			tables = append(tables, encodeTable{
				min:   key,
				max:   key,
				table: []int16{int16(encode[key])},
			})
			last = key
			continue
		}
		t := &tables[len(tables)-1]
		for i := t.max + 1; i < key; i++ {
			t.table = append(t.table, -1)
		}
		t.max = key
		t.table = append(t.table, int16(encode[key]))
		last = key
	}
	return tables
}
